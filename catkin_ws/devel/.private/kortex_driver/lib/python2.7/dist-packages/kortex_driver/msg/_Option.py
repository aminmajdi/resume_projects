# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from kortex_driver/Option.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class Option(genpy.Message):
  _md5sum = "0f091628538d1f237d2c9bbe103cea73"
  _type = "kortex_driver/Option"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """
uint32 OPTION_UNSPECIFIED = 0

uint32 OPTION_BACKLIGHT_COMPENSATION = 1

uint32 OPTION_BRIGHTNESS = 2

uint32 OPTION_CONTRAST = 3

uint32 OPTION_EXPOSURE = 4

uint32 OPTION_GAIN = 5

uint32 OPTION_GAMMA = 6

uint32 OPTION_HUE = 7

uint32 OPTION_SATURATION = 8

uint32 OPTION_SHARPNESS = 9

uint32 OPTION_WHITE_BALANCE = 10

uint32 OPTION_ENABLE_AUTO_EXPOSURE = 11

uint32 OPTION_ENABLE_AUTO_WHITE_BALANCE = 12

uint32 OPTION_VISUAL_PRESET = 13

uint32 OPTION_LASER_POWER = 14

uint32 OPTION_ACCURACY = 15

uint32 OPTION_MOTION_RANGE = 16

uint32 OPTION_FILTER_OPTION = 17

uint32 OPTION_CONFIDENCE_THRESHOLD = 18

uint32 OPTION_EMITTER_ENABLED = 19

uint32 OPTION_FRAMES_QUEUE_SIZE = 20

uint32 OPTION_TOTAL_FRAME_DROPS = 21

uint32 OPTION_AUTO_EXPOSURE_MODE = 22

uint32 OPTION_POWER_LINE_FREQUENCY = 23

uint32 OPTION_ASIC_TEMPERATURE = 24

uint32 OPTION_ERROR_POLLING_ENABLED = 25

uint32 OPTION_PROJECTOR_TEMPERATURE = 26

uint32 OPTION_OUTPUT_TRIGGER_ENABLED = 27

uint32 OPTION_MOTION_MODULE_TEMPERATURE = 28

uint32 OPTION_DEPTH_UNITS = 29

uint32 OPTION_ENABLE_MOTION_CORRECTION = 30

uint32 OPTION_AUTO_EXPOSURE_PRIORITY = 31

uint32 OPTION_COLOR_SCHEME = 32

uint32 OPTION_HISTOGRAM_EQUALIZATION_ENABLED = 33

uint32 OPTION_MIN_DISTANCE = 34

uint32 OPTION_MAX_DISTANCE = 35

uint32 OPTION_TEXTURE_SOURCE = 36

uint32 OPTION_FILTER_MAGNITUDE = 37

uint32 OPTION_FILTER_SMOOTH_ALPHA = 38

uint32 OPTION_FILTER_SMOOTH_DELTA = 39

uint32 OPTION_HOLES_FILL = 40

uint32 OPTION_STEREO_BASELINE = 41

uint32 OPTION_AUTO_EXPOSURE_CONVERGE_STEP = 42
"""
  # Pseudo-constants
  OPTION_UNSPECIFIED = 0
  OPTION_BACKLIGHT_COMPENSATION = 1
  OPTION_BRIGHTNESS = 2
  OPTION_CONTRAST = 3
  OPTION_EXPOSURE = 4
  OPTION_GAIN = 5
  OPTION_GAMMA = 6
  OPTION_HUE = 7
  OPTION_SATURATION = 8
  OPTION_SHARPNESS = 9
  OPTION_WHITE_BALANCE = 10
  OPTION_ENABLE_AUTO_EXPOSURE = 11
  OPTION_ENABLE_AUTO_WHITE_BALANCE = 12
  OPTION_VISUAL_PRESET = 13
  OPTION_LASER_POWER = 14
  OPTION_ACCURACY = 15
  OPTION_MOTION_RANGE = 16
  OPTION_FILTER_OPTION = 17
  OPTION_CONFIDENCE_THRESHOLD = 18
  OPTION_EMITTER_ENABLED = 19
  OPTION_FRAMES_QUEUE_SIZE = 20
  OPTION_TOTAL_FRAME_DROPS = 21
  OPTION_AUTO_EXPOSURE_MODE = 22
  OPTION_POWER_LINE_FREQUENCY = 23
  OPTION_ASIC_TEMPERATURE = 24
  OPTION_ERROR_POLLING_ENABLED = 25
  OPTION_PROJECTOR_TEMPERATURE = 26
  OPTION_OUTPUT_TRIGGER_ENABLED = 27
  OPTION_MOTION_MODULE_TEMPERATURE = 28
  OPTION_DEPTH_UNITS = 29
  OPTION_ENABLE_MOTION_CORRECTION = 30
  OPTION_AUTO_EXPOSURE_PRIORITY = 31
  OPTION_COLOR_SCHEME = 32
  OPTION_HISTOGRAM_EQUALIZATION_ENABLED = 33
  OPTION_MIN_DISTANCE = 34
  OPTION_MAX_DISTANCE = 35
  OPTION_TEXTURE_SOURCE = 36
  OPTION_FILTER_MAGNITUDE = 37
  OPTION_FILTER_SMOOTH_ALPHA = 38
  OPTION_FILTER_SMOOTH_DELTA = 39
  OPTION_HOLES_FILL = 40
  OPTION_STEREO_BASELINE = 41
  OPTION_AUTO_EXPOSURE_CONVERGE_STEP = 42

  __slots__ = []
  _slot_types = []

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(Option, self).__init__(*args, **kwds)

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      pass
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      pass
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
