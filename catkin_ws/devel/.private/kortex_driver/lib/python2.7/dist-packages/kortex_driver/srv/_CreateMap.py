# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from kortex_driver/CreateMapRequest.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import kortex_driver.msg

class CreateMapRequest(genpy.Message):
  _md5sum = "6fef017f62bb2df3d815fecaf9d646b1"
  _type = "kortex_driver/CreateMapRequest"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """Map input

================================================================================
MSG: kortex_driver/Map

MapHandle handle
string name
MapElement[] elements
================================================================================
MSG: kortex_driver/MapHandle

uint32 identifier
uint32 permission
================================================================================
MSG: kortex_driver/MapElement

MapEvent event
Action action
string name
================================================================================
MSG: kortex_driver/MapEvent

string name
MapEvent_events oneof_events
================================================================================
MSG: kortex_driver/MapEvent_events

SafetyEvent[] safety_event
GpioEvent[] gpio_event
ControllerEvent[] controller_event
================================================================================
MSG: kortex_driver/SafetyEvent

SafetyHandle safety_handle
================================================================================
MSG: kortex_driver/SafetyHandle

uint32 identifier
================================================================================
MSG: kortex_driver/GpioEvent

uint32 input_type
uint32 behavior
uint32 input_identifier
================================================================================
MSG: kortex_driver/ControllerEvent

uint32 input_type
uint32 behavior
uint32 input_identifier
================================================================================
MSG: kortex_driver/Action

ActionHandle handle
string name
string application_data
Action_action_parameters oneof_action_parameters
================================================================================
MSG: kortex_driver/ActionHandle

uint32 identifier
uint32 action_type
uint32 permission
================================================================================
MSG: kortex_driver/Action_action_parameters

TwistCommand[] send_twist_command
WrenchCommand[] send_wrench_command
Base_JointSpeeds[] send_joint_speeds
ConstrainedPose[] reach_pose
ConstrainedJointAngles[] reach_joint_angles
uint32[] toggle_admittance_mode
Snapshot[] snapshot
SwitchControlMapping[] switch_control_mapping
uint32[] navigate_joints
uint32[] navigate_mappings
ChangeTwist[] change_twist
ChangeJointSpeeds[] change_joint_speeds
ChangeWrench[] change_wrench
EmergencyStop[] apply_emergency_stop
Faults[] clear_faults
Delay[] delay
ActionHandle[] execute_action
GripperCommand[] send_gripper_command
Base_Stop[] stop_action
PreComputedJointTrajectory[] play_pre_computed_trajectory
================================================================================
MSG: kortex_driver/TwistCommand

uint32 reference_frame
Twist twist
uint32 duration
================================================================================
MSG: kortex_driver/Twist

float32 linear_x
float32 linear_y
float32 linear_z
float32 angular_x
float32 angular_y
float32 angular_z
================================================================================
MSG: kortex_driver/WrenchCommand

uint32 reference_frame
uint32 mode
Wrench wrench
uint32 duration
================================================================================
MSG: kortex_driver/Wrench

float32 force_x
float32 force_y
float32 force_z
float32 torque_x
float32 torque_y
float32 torque_z
================================================================================
MSG: kortex_driver/Base_JointSpeeds

JointSpeed[] joint_speeds
uint32 duration
================================================================================
MSG: kortex_driver/JointSpeed

uint32 joint_identifier
float32 value
uint32 duration
================================================================================
MSG: kortex_driver/ConstrainedPose

Pose target_pose
CartesianTrajectoryConstraint constraint
================================================================================
MSG: kortex_driver/Pose

float32 x
float32 y
float32 z
float32 theta_x
float32 theta_y
float32 theta_z
================================================================================
MSG: kortex_driver/CartesianTrajectoryConstraint

CartesianTrajectoryConstraint_type oneof_type
================================================================================
MSG: kortex_driver/CartesianTrajectoryConstraint_type

CartesianSpeed[] speed
uint32[] duration
================================================================================
MSG: kortex_driver/CartesianSpeed

float32 translation
float32 orientation
================================================================================
MSG: kortex_driver/ConstrainedJointAngles

JointAngles joint_angles
JointTrajectoryConstraint constraint
================================================================================
MSG: kortex_driver/JointAngles

JointAngle[] joint_angles
================================================================================
MSG: kortex_driver/JointAngle

uint32 joint_identifier
float32 value
================================================================================
MSG: kortex_driver/JointTrajectoryConstraint

uint32 type
float32 value
================================================================================
MSG: kortex_driver/Snapshot

uint32 snapshot_type
================================================================================
MSG: kortex_driver/SwitchControlMapping

uint32 controller_identifier
MapGroupHandle map_group_handle
MapHandle map_handle
================================================================================
MSG: kortex_driver/MapGroupHandle

uint32 identifier
uint32 permission
================================================================================
MSG: kortex_driver/ChangeTwist

float32 linear
float32 angular
================================================================================
MSG: kortex_driver/ChangeJointSpeeds

Base_JointSpeeds joint_speeds
================================================================================
MSG: kortex_driver/ChangeWrench

float32 force
float32 torque
================================================================================
MSG: kortex_driver/EmergencyStop

================================================================================
MSG: kortex_driver/Faults

================================================================================
MSG: kortex_driver/Delay

uint32 duration
================================================================================
MSG: kortex_driver/GripperCommand

uint32 mode
Gripper gripper
uint32 duration
================================================================================
MSG: kortex_driver/Gripper

Finger[] finger
================================================================================
MSG: kortex_driver/Finger

uint32 finger_identifier
float32 value
================================================================================
MSG: kortex_driver/Base_Stop

================================================================================
MSG: kortex_driver/PreComputedJointTrajectory

uint32 mode
PreComputedJointTrajectoryElement[] trajectory_elements
================================================================================
MSG: kortex_driver/PreComputedJointTrajectoryElement

float32[] joint_angles
float32[] joint_speeds
float32[] joint_accelerations
float32 time_from_start"""
  __slots__ = ['input']
  _slot_types = ['kortex_driver/Map']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       input

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(CreateMapRequest, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.input is None:
        self.input = kortex_driver.msg.Map()
    else:
      self.input = kortex_driver.msg.Map()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_2I().pack(_x.input.handle.identifier, _x.input.handle.permission))
      _x = self.input.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.input.elements)
      buff.write(_struct_I.pack(length))
      for val1 in self.input.elements:
        _v1 = val1.event
        _x = _v1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v2 = _v1.oneof_events
        length = len(_v2.safety_event)
        buff.write(_struct_I.pack(length))
        for val4 in _v2.safety_event:
          _v3 = val4.safety_handle
          _x = _v3.identifier
          buff.write(_get_struct_I().pack(_x))
        length = len(_v2.gpio_event)
        buff.write(_struct_I.pack(length))
        for val4 in _v2.gpio_event:
          _x = val4
          buff.write(_get_struct_3I().pack(_x.input_type, _x.behavior, _x.input_identifier))
        length = len(_v2.controller_event)
        buff.write(_struct_I.pack(length))
        for val4 in _v2.controller_event:
          _x = val4
          buff.write(_get_struct_3I().pack(_x.input_type, _x.behavior, _x.input_identifier))
        _v4 = val1.action
        _v5 = _v4.handle
        _x = _v5
        buff.write(_get_struct_3I().pack(_x.identifier, _x.action_type, _x.permission))
        _x = _v4.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v4.application_data
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v6 = _v4.oneof_action_parameters
        length = len(_v6.send_twist_command)
        buff.write(_struct_I.pack(length))
        for val4 in _v6.send_twist_command:
          _x = val4.reference_frame
          buff.write(_get_struct_I().pack(_x))
          _v7 = val4.twist
          _x = _v7
          buff.write(_get_struct_6f().pack(_x.linear_x, _x.linear_y, _x.linear_z, _x.angular_x, _x.angular_y, _x.angular_z))
          _x = val4.duration
          buff.write(_get_struct_I().pack(_x))
        length = len(_v6.send_wrench_command)
        buff.write(_struct_I.pack(length))
        for val4 in _v6.send_wrench_command:
          _x = val4
          buff.write(_get_struct_2I().pack(_x.reference_frame, _x.mode))
          _v8 = val4.wrench
          _x = _v8
          buff.write(_get_struct_6f().pack(_x.force_x, _x.force_y, _x.force_z, _x.torque_x, _x.torque_y, _x.torque_z))
          _x = val4.duration
          buff.write(_get_struct_I().pack(_x))
        length = len(_v6.send_joint_speeds)
        buff.write(_struct_I.pack(length))
        for val4 in _v6.send_joint_speeds:
          length = len(val4.joint_speeds)
          buff.write(_struct_I.pack(length))
          for val5 in val4.joint_speeds:
            _x = val5
            buff.write(_get_struct_IfI().pack(_x.joint_identifier, _x.value, _x.duration))
          _x = val4.duration
          buff.write(_get_struct_I().pack(_x))
        length = len(_v6.reach_pose)
        buff.write(_struct_I.pack(length))
        for val4 in _v6.reach_pose:
          _v9 = val4.target_pose
          _x = _v9
          buff.write(_get_struct_6f().pack(_x.x, _x.y, _x.z, _x.theta_x, _x.theta_y, _x.theta_z))
          _v10 = val4.constraint
          _v11 = _v10.oneof_type
          length = len(_v11.speed)
          buff.write(_struct_I.pack(length))
          for val7 in _v11.speed:
            _x = val7
            buff.write(_get_struct_2f().pack(_x.translation, _x.orientation))
          length = len(_v11.duration)
          buff.write(_struct_I.pack(length))
          pattern = '<%sI'%length
          buff.write(struct.Struct(pattern).pack(*_v11.duration))
        length = len(_v6.reach_joint_angles)
        buff.write(_struct_I.pack(length))
        for val4 in _v6.reach_joint_angles:
          _v12 = val4.joint_angles
          length = len(_v12.joint_angles)
          buff.write(_struct_I.pack(length))
          for val6 in _v12.joint_angles:
            _x = val6
            buff.write(_get_struct_If().pack(_x.joint_identifier, _x.value))
          _v13 = val4.constraint
          _x = _v13
          buff.write(_get_struct_If().pack(_x.type, _x.value))
        length = len(_v6.toggle_admittance_mode)
        buff.write(_struct_I.pack(length))
        pattern = '<%sI'%length
        buff.write(struct.Struct(pattern).pack(*_v6.toggle_admittance_mode))
        length = len(_v6.snapshot)
        buff.write(_struct_I.pack(length))
        for val4 in _v6.snapshot:
          _x = val4.snapshot_type
          buff.write(_get_struct_I().pack(_x))
        length = len(_v6.switch_control_mapping)
        buff.write(_struct_I.pack(length))
        for val4 in _v6.switch_control_mapping:
          _x = val4.controller_identifier
          buff.write(_get_struct_I().pack(_x))
          _v14 = val4.map_group_handle
          _x = _v14
          buff.write(_get_struct_2I().pack(_x.identifier, _x.permission))
          _v15 = val4.map_handle
          _x = _v15
          buff.write(_get_struct_2I().pack(_x.identifier, _x.permission))
        length = len(_v6.navigate_joints)
        buff.write(_struct_I.pack(length))
        pattern = '<%sI'%length
        buff.write(struct.Struct(pattern).pack(*_v6.navigate_joints))
        length = len(_v6.navigate_mappings)
        buff.write(_struct_I.pack(length))
        pattern = '<%sI'%length
        buff.write(struct.Struct(pattern).pack(*_v6.navigate_mappings))
        length = len(_v6.change_twist)
        buff.write(_struct_I.pack(length))
        for val4 in _v6.change_twist:
          _x = val4
          buff.write(_get_struct_2f().pack(_x.linear, _x.angular))
        length = len(_v6.change_joint_speeds)
        buff.write(_struct_I.pack(length))
        for val4 in _v6.change_joint_speeds:
          _v16 = val4.joint_speeds
          length = len(_v16.joint_speeds)
          buff.write(_struct_I.pack(length))
          for val6 in _v16.joint_speeds:
            _x = val6
            buff.write(_get_struct_IfI().pack(_x.joint_identifier, _x.value, _x.duration))
          _x = _v16.duration
          buff.write(_get_struct_I().pack(_x))
        length = len(_v6.change_wrench)
        buff.write(_struct_I.pack(length))
        for val4 in _v6.change_wrench:
          _x = val4
          buff.write(_get_struct_2f().pack(_x.force, _x.torque))
        length = len(_v6.apply_emergency_stop)
        buff.write(_struct_I.pack(length))
        for val4 in _v6.apply_emergency_stop:
          pass
        length = len(_v6.clear_faults)
        buff.write(_struct_I.pack(length))
        for val4 in _v6.clear_faults:
          pass
        length = len(_v6.delay)
        buff.write(_struct_I.pack(length))
        for val4 in _v6.delay:
          _x = val4.duration
          buff.write(_get_struct_I().pack(_x))
        length = len(_v6.execute_action)
        buff.write(_struct_I.pack(length))
        for val4 in _v6.execute_action:
          _x = val4
          buff.write(_get_struct_3I().pack(_x.identifier, _x.action_type, _x.permission))
        length = len(_v6.send_gripper_command)
        buff.write(_struct_I.pack(length))
        for val4 in _v6.send_gripper_command:
          _x = val4.mode
          buff.write(_get_struct_I().pack(_x))
          _v17 = val4.gripper
          length = len(_v17.finger)
          buff.write(_struct_I.pack(length))
          for val6 in _v17.finger:
            _x = val6
            buff.write(_get_struct_If().pack(_x.finger_identifier, _x.value))
          _x = val4.duration
          buff.write(_get_struct_I().pack(_x))
        length = len(_v6.stop_action)
        buff.write(_struct_I.pack(length))
        for val4 in _v6.stop_action:
          pass
        length = len(_v6.play_pre_computed_trajectory)
        buff.write(_struct_I.pack(length))
        for val4 in _v6.play_pre_computed_trajectory:
          _x = val4.mode
          buff.write(_get_struct_I().pack(_x))
          length = len(val4.trajectory_elements)
          buff.write(_struct_I.pack(length))
          for val5 in val4.trajectory_elements:
            length = len(val5.joint_angles)
            buff.write(_struct_I.pack(length))
            pattern = '<%sf'%length
            buff.write(struct.Struct(pattern).pack(*val5.joint_angles))
            length = len(val5.joint_speeds)
            buff.write(_struct_I.pack(length))
            pattern = '<%sf'%length
            buff.write(struct.Struct(pattern).pack(*val5.joint_speeds))
            length = len(val5.joint_accelerations)
            buff.write(_struct_I.pack(length))
            pattern = '<%sf'%length
            buff.write(struct.Struct(pattern).pack(*val5.joint_accelerations))
            _x = val5.time_from_start
            buff.write(_get_struct_f().pack(_x))
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.input is None:
        self.input = kortex_driver.msg.Map()
      end = 0
      _x = self
      start = end
      end += 8
      (_x.input.handle.identifier, _x.input.handle.permission,) = _get_struct_2I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.input.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.input.name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.input.elements = []
      for i in range(0, length):
        val1 = kortex_driver.msg.MapElement()
        _v18 = val1.event
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v18.name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v18.name = str[start:end]
        _v19 = _v18.oneof_events
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v19.safety_event = []
        for i in range(0, length):
          val4 = kortex_driver.msg.SafetyEvent()
          _v20 = val4.safety_handle
          start = end
          end += 4
          (_v20.identifier,) = _get_struct_I().unpack(str[start:end])
          _v19.safety_event.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v19.gpio_event = []
        for i in range(0, length):
          val4 = kortex_driver.msg.GpioEvent()
          _x = val4
          start = end
          end += 12
          (_x.input_type, _x.behavior, _x.input_identifier,) = _get_struct_3I().unpack(str[start:end])
          _v19.gpio_event.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v19.controller_event = []
        for i in range(0, length):
          val4 = kortex_driver.msg.ControllerEvent()
          _x = val4
          start = end
          end += 12
          (_x.input_type, _x.behavior, _x.input_identifier,) = _get_struct_3I().unpack(str[start:end])
          _v19.controller_event.append(val4)
        _v21 = val1.action
        _v22 = _v21.handle
        _x = _v22
        start = end
        end += 12
        (_x.identifier, _x.action_type, _x.permission,) = _get_struct_3I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v21.name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v21.name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v21.application_data = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v21.application_data = str[start:end]
        _v23 = _v21.oneof_action_parameters
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v23.send_twist_command = []
        for i in range(0, length):
          val4 = kortex_driver.msg.TwistCommand()
          start = end
          end += 4
          (val4.reference_frame,) = _get_struct_I().unpack(str[start:end])
          _v24 = val4.twist
          _x = _v24
          start = end
          end += 24
          (_x.linear_x, _x.linear_y, _x.linear_z, _x.angular_x, _x.angular_y, _x.angular_z,) = _get_struct_6f().unpack(str[start:end])
          start = end
          end += 4
          (val4.duration,) = _get_struct_I().unpack(str[start:end])
          _v23.send_twist_command.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v23.send_wrench_command = []
        for i in range(0, length):
          val4 = kortex_driver.msg.WrenchCommand()
          _x = val4
          start = end
          end += 8
          (_x.reference_frame, _x.mode,) = _get_struct_2I().unpack(str[start:end])
          _v25 = val4.wrench
          _x = _v25
          start = end
          end += 24
          (_x.force_x, _x.force_y, _x.force_z, _x.torque_x, _x.torque_y, _x.torque_z,) = _get_struct_6f().unpack(str[start:end])
          start = end
          end += 4
          (val4.duration,) = _get_struct_I().unpack(str[start:end])
          _v23.send_wrench_command.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v23.send_joint_speeds = []
        for i in range(0, length):
          val4 = kortex_driver.msg.Base_JointSpeeds()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val4.joint_speeds = []
          for i in range(0, length):
            val5 = kortex_driver.msg.JointSpeed()
            _x = val5
            start = end
            end += 12
            (_x.joint_identifier, _x.value, _x.duration,) = _get_struct_IfI().unpack(str[start:end])
            val4.joint_speeds.append(val5)
          start = end
          end += 4
          (val4.duration,) = _get_struct_I().unpack(str[start:end])
          _v23.send_joint_speeds.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v23.reach_pose = []
        for i in range(0, length):
          val4 = kortex_driver.msg.ConstrainedPose()
          _v26 = val4.target_pose
          _x = _v26
          start = end
          end += 24
          (_x.x, _x.y, _x.z, _x.theta_x, _x.theta_y, _x.theta_z,) = _get_struct_6f().unpack(str[start:end])
          _v27 = val4.constraint
          _v28 = _v27.oneof_type
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v28.speed = []
          for i in range(0, length):
            val7 = kortex_driver.msg.CartesianSpeed()
            _x = val7
            start = end
            end += 8
            (_x.translation, _x.orientation,) = _get_struct_2f().unpack(str[start:end])
            _v28.speed.append(val7)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sI'%length
          start = end
          s = struct.Struct(pattern)
          end += s.size
          _v28.duration = s.unpack(str[start:end])
          _v23.reach_pose.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v23.reach_joint_angles = []
        for i in range(0, length):
          val4 = kortex_driver.msg.ConstrainedJointAngles()
          _v29 = val4.joint_angles
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v29.joint_angles = []
          for i in range(0, length):
            val6 = kortex_driver.msg.JointAngle()
            _x = val6
            start = end
            end += 8
            (_x.joint_identifier, _x.value,) = _get_struct_If().unpack(str[start:end])
            _v29.joint_angles.append(val6)
          _v30 = val4.constraint
          _x = _v30
          start = end
          end += 8
          (_x.type, _x.value,) = _get_struct_If().unpack(str[start:end])
          _v23.reach_joint_angles.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sI'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v23.toggle_admittance_mode = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v23.snapshot = []
        for i in range(0, length):
          val4 = kortex_driver.msg.Snapshot()
          start = end
          end += 4
          (val4.snapshot_type,) = _get_struct_I().unpack(str[start:end])
          _v23.snapshot.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v23.switch_control_mapping = []
        for i in range(0, length):
          val4 = kortex_driver.msg.SwitchControlMapping()
          start = end
          end += 4
          (val4.controller_identifier,) = _get_struct_I().unpack(str[start:end])
          _v31 = val4.map_group_handle
          _x = _v31
          start = end
          end += 8
          (_x.identifier, _x.permission,) = _get_struct_2I().unpack(str[start:end])
          _v32 = val4.map_handle
          _x = _v32
          start = end
          end += 8
          (_x.identifier, _x.permission,) = _get_struct_2I().unpack(str[start:end])
          _v23.switch_control_mapping.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sI'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v23.navigate_joints = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sI'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v23.navigate_mappings = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v23.change_twist = []
        for i in range(0, length):
          val4 = kortex_driver.msg.ChangeTwist()
          _x = val4
          start = end
          end += 8
          (_x.linear, _x.angular,) = _get_struct_2f().unpack(str[start:end])
          _v23.change_twist.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v23.change_joint_speeds = []
        for i in range(0, length):
          val4 = kortex_driver.msg.ChangeJointSpeeds()
          _v33 = val4.joint_speeds
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v33.joint_speeds = []
          for i in range(0, length):
            val6 = kortex_driver.msg.JointSpeed()
            _x = val6
            start = end
            end += 12
            (_x.joint_identifier, _x.value, _x.duration,) = _get_struct_IfI().unpack(str[start:end])
            _v33.joint_speeds.append(val6)
          start = end
          end += 4
          (_v33.duration,) = _get_struct_I().unpack(str[start:end])
          _v23.change_joint_speeds.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v23.change_wrench = []
        for i in range(0, length):
          val4 = kortex_driver.msg.ChangeWrench()
          _x = val4
          start = end
          end += 8
          (_x.force, _x.torque,) = _get_struct_2f().unpack(str[start:end])
          _v23.change_wrench.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v23.apply_emergency_stop = []
        for i in range(0, length):
          val4 = kortex_driver.msg.EmergencyStop()
          _v23.apply_emergency_stop.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v23.clear_faults = []
        for i in range(0, length):
          val4 = kortex_driver.msg.Faults()
          _v23.clear_faults.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v23.delay = []
        for i in range(0, length):
          val4 = kortex_driver.msg.Delay()
          start = end
          end += 4
          (val4.duration,) = _get_struct_I().unpack(str[start:end])
          _v23.delay.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v23.execute_action = []
        for i in range(0, length):
          val4 = kortex_driver.msg.ActionHandle()
          _x = val4
          start = end
          end += 12
          (_x.identifier, _x.action_type, _x.permission,) = _get_struct_3I().unpack(str[start:end])
          _v23.execute_action.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v23.send_gripper_command = []
        for i in range(0, length):
          val4 = kortex_driver.msg.GripperCommand()
          start = end
          end += 4
          (val4.mode,) = _get_struct_I().unpack(str[start:end])
          _v34 = val4.gripper
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v34.finger = []
          for i in range(0, length):
            val6 = kortex_driver.msg.Finger()
            _x = val6
            start = end
            end += 8
            (_x.finger_identifier, _x.value,) = _get_struct_If().unpack(str[start:end])
            _v34.finger.append(val6)
          start = end
          end += 4
          (val4.duration,) = _get_struct_I().unpack(str[start:end])
          _v23.send_gripper_command.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v23.stop_action = []
        for i in range(0, length):
          val4 = kortex_driver.msg.Base_Stop()
          _v23.stop_action.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v23.play_pre_computed_trajectory = []
        for i in range(0, length):
          val4 = kortex_driver.msg.PreComputedJointTrajectory()
          start = end
          end += 4
          (val4.mode,) = _get_struct_I().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val4.trajectory_elements = []
          for i in range(0, length):
            val5 = kortex_driver.msg.PreComputedJointTrajectoryElement()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            pattern = '<%sf'%length
            start = end
            s = struct.Struct(pattern)
            end += s.size
            val5.joint_angles = s.unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            pattern = '<%sf'%length
            start = end
            s = struct.Struct(pattern)
            end += s.size
            val5.joint_speeds = s.unpack(str[start:end])
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            pattern = '<%sf'%length
            start = end
            s = struct.Struct(pattern)
            end += s.size
            val5.joint_accelerations = s.unpack(str[start:end])
            start = end
            end += 4
            (val5.time_from_start,) = _get_struct_f().unpack(str[start:end])
            val4.trajectory_elements.append(val5)
          _v23.play_pre_computed_trajectory.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.name = str[start:end]
        self.input.elements.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_2I().pack(_x.input.handle.identifier, _x.input.handle.permission))
      _x = self.input.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.input.elements)
      buff.write(_struct_I.pack(length))
      for val1 in self.input.elements:
        _v35 = val1.event
        _x = _v35.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v36 = _v35.oneof_events
        length = len(_v36.safety_event)
        buff.write(_struct_I.pack(length))
        for val4 in _v36.safety_event:
          _v37 = val4.safety_handle
          _x = _v37.identifier
          buff.write(_get_struct_I().pack(_x))
        length = len(_v36.gpio_event)
        buff.write(_struct_I.pack(length))
        for val4 in _v36.gpio_event:
          _x = val4
          buff.write(_get_struct_3I().pack(_x.input_type, _x.behavior, _x.input_identifier))
        length = len(_v36.controller_event)
        buff.write(_struct_I.pack(length))
        for val4 in _v36.controller_event:
          _x = val4
          buff.write(_get_struct_3I().pack(_x.input_type, _x.behavior, _x.input_identifier))
        _v38 = val1.action
        _v39 = _v38.handle
        _x = _v39
        buff.write(_get_struct_3I().pack(_x.identifier, _x.action_type, _x.permission))
        _x = _v38.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v38.application_data
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v40 = _v38.oneof_action_parameters
        length = len(_v40.send_twist_command)
        buff.write(_struct_I.pack(length))
        for val4 in _v40.send_twist_command:
          _x = val4.reference_frame
          buff.write(_get_struct_I().pack(_x))
          _v41 = val4.twist
          _x = _v41
          buff.write(_get_struct_6f().pack(_x.linear_x, _x.linear_y, _x.linear_z, _x.angular_x, _x.angular_y, _x.angular_z))
          _x = val4.duration
          buff.write(_get_struct_I().pack(_x))
        length = len(_v40.send_wrench_command)
        buff.write(_struct_I.pack(length))
        for val4 in _v40.send_wrench_command:
          _x = val4
          buff.write(_get_struct_2I().pack(_x.reference_frame, _x.mode))
          _v42 = val4.wrench
          _x = _v42
          buff.write(_get_struct_6f().pack(_x.force_x, _x.force_y, _x.force_z, _x.torque_x, _x.torque_y, _x.torque_z))
          _x = val4.duration
          buff.write(_get_struct_I().pack(_x))
        length = len(_v40.send_joint_speeds)
        buff.write(_struct_I.pack(length))
        for val4 in _v40.send_joint_speeds:
          length = len(val4.joint_speeds)
          buff.write(_struct_I.pack(length))
          for val5 in val4.joint_speeds:
            _x = val5
            buff.write(_get_struct_IfI().pack(_x.joint_identifier, _x.value, _x.duration))
          _x = val4.duration
          buff.write(_get_struct_I().pack(_x))
        length = len(_v40.reach_pose)
        buff.write(_struct_I.pack(length))
        for val4 in _v40.reach_pose:
          _v43 = val4.target_pose
          _x = _v43
          buff.write(_get_struct_6f().pack(_x.x, _x.y, _x.z, _x.theta_x, _x.theta_y, _x.theta_z))
          _v44 = val4.constraint
          _v45 = _v44.oneof_type
          length = len(_v45.speed)
          buff.write(_struct_I.pack(length))
          for val7 in _v45.speed:
            _x = val7
            buff.write(_get_struct_2f().pack(_x.translation, _x.orientation))
          length = len(_v45.duration)
          buff.write(_struct_I.pack(length))
          pattern = '<%sI'%length
          buff.write(_v45.duration.tostring())
        length = len(_v40.reach_joint_angles)
        buff.write(_struct_I.pack(length))
        for val4 in _v40.reach_joint_angles:
          _v46 = val4.joint_angles
          length = len(_v46.joint_angles)
          buff.write(_struct_I.pack(length))
          for val6 in _v46.joint_angles:
            _x = val6
            buff.write(_get_struct_If().pack(_x.joint_identifier, _x.value))
          _v47 = val4.constraint
          _x = _v47
          buff.write(_get_struct_If().pack(_x.type, _x.value))
        length = len(_v40.toggle_admittance_mode)
        buff.write(_struct_I.pack(length))
        pattern = '<%sI'%length
        buff.write(_v40.toggle_admittance_mode.tostring())
        length = len(_v40.snapshot)
        buff.write(_struct_I.pack(length))
        for val4 in _v40.snapshot:
          _x = val4.snapshot_type
          buff.write(_get_struct_I().pack(_x))
        length = len(_v40.switch_control_mapping)
        buff.write(_struct_I.pack(length))
        for val4 in _v40.switch_control_mapping:
          _x = val4.controller_identifier
          buff.write(_get_struct_I().pack(_x))
          _v48 = val4.map_group_handle
          _x = _v48
          buff.write(_get_struct_2I().pack(_x.identifier, _x.permission))
          _v49 = val4.map_handle
          _x = _v49
          buff.write(_get_struct_2I().pack(_x.identifier, _x.permission))
        length = len(_v40.navigate_joints)
        buff.write(_struct_I.pack(length))
        pattern = '<%sI'%length
        buff.write(_v40.navigate_joints.tostring())
        length = len(_v40.navigate_mappings)
        buff.write(_struct_I.pack(length))
        pattern = '<%sI'%length
        buff.write(_v40.navigate_mappings.tostring())
        length = len(_v40.change_twist)
        buff.write(_struct_I.pack(length))
        for val4 in _v40.change_twist:
          _x = val4
          buff.write(_get_struct_2f().pack(_x.linear, _x.angular))
        length = len(_v40.change_joint_speeds)
        buff.write(_struct_I.pack(length))
        for val4 in _v40.change_joint_speeds:
          _v50 = val4.joint_speeds
          length = len(_v50.joint_speeds)
          buff.write(_struct_I.pack(length))
          for val6 in _v50.joint_speeds:
            _x = val6
            buff.write(_get_struct_IfI().pack(_x.joint_identifier, _x.value, _x.duration))
          _x = _v50.duration
          buff.write(_get_struct_I().pack(_x))
        length = len(_v40.change_wrench)
        buff.write(_struct_I.pack(length))
        for val4 in _v40.change_wrench:
          _x = val4
          buff.write(_get_struct_2f().pack(_x.force, _x.torque))
        length = len(_v40.apply_emergency_stop)
        buff.write(_struct_I.pack(length))
        for val4 in _v40.apply_emergency_stop:
          pass
        length = len(_v40.clear_faults)
        buff.write(_struct_I.pack(length))
        for val4 in _v40.clear_faults:
          pass
        length = len(_v40.delay)
        buff.write(_struct_I.pack(length))
        for val4 in _v40.delay:
          _x = val4.duration
          buff.write(_get_struct_I().pack(_x))
        length = len(_v40.execute_action)
        buff.write(_struct_I.pack(length))
        for val4 in _v40.execute_action:
          _x = val4
          buff.write(_get_struct_3I().pack(_x.identifier, _x.action_type, _x.permission))
        length = len(_v40.send_gripper_command)
        buff.write(_struct_I.pack(length))
        for val4 in _v40.send_gripper_command:
          _x = val4.mode
          buff.write(_get_struct_I().pack(_x))
          _v51 = val4.gripper
          length = len(_v51.finger)
          buff.write(_struct_I.pack(length))
          for val6 in _v51.finger:
            _x = val6
            buff.write(_get_struct_If().pack(_x.finger_identifier, _x.value))
          _x = val4.duration
          buff.write(_get_struct_I().pack(_x))
        length = len(_v40.stop_action)
        buff.write(_struct_I.pack(length))
        for val4 in _v40.stop_action:
          pass
        length = len(_v40.play_pre_computed_trajectory)
        buff.write(_struct_I.pack(length))
        for val4 in _v40.play_pre_computed_trajectory:
          _x = val4.mode
          buff.write(_get_struct_I().pack(_x))
          length = len(val4.trajectory_elements)
          buff.write(_struct_I.pack(length))
          for val5 in val4.trajectory_elements:
            length = len(val5.joint_angles)
            buff.write(_struct_I.pack(length))
            pattern = '<%sf'%length
            buff.write(val5.joint_angles.tostring())
            length = len(val5.joint_speeds)
            buff.write(_struct_I.pack(length))
            pattern = '<%sf'%length
            buff.write(val5.joint_speeds.tostring())
            length = len(val5.joint_accelerations)
            buff.write(_struct_I.pack(length))
            pattern = '<%sf'%length
            buff.write(val5.joint_accelerations.tostring())
            _x = val5.time_from_start
            buff.write(_get_struct_f().pack(_x))
        _x = val1.name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.input is None:
        self.input = kortex_driver.msg.Map()
      end = 0
      _x = self
      start = end
      end += 8
      (_x.input.handle.identifier, _x.input.handle.permission,) = _get_struct_2I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.input.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.input.name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.input.elements = []
      for i in range(0, length):
        val1 = kortex_driver.msg.MapElement()
        _v52 = val1.event
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v52.name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v52.name = str[start:end]
        _v53 = _v52.oneof_events
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v53.safety_event = []
        for i in range(0, length):
          val4 = kortex_driver.msg.SafetyEvent()
          _v54 = val4.safety_handle
          start = end
          end += 4
          (_v54.identifier,) = _get_struct_I().unpack(str[start:end])
          _v53.safety_event.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v53.gpio_event = []
        for i in range(0, length):
          val4 = kortex_driver.msg.GpioEvent()
          _x = val4
          start = end
          end += 12
          (_x.input_type, _x.behavior, _x.input_identifier,) = _get_struct_3I().unpack(str[start:end])
          _v53.gpio_event.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v53.controller_event = []
        for i in range(0, length):
          val4 = kortex_driver.msg.ControllerEvent()
          _x = val4
          start = end
          end += 12
          (_x.input_type, _x.behavior, _x.input_identifier,) = _get_struct_3I().unpack(str[start:end])
          _v53.controller_event.append(val4)
        _v55 = val1.action
        _v56 = _v55.handle
        _x = _v56
        start = end
        end += 12
        (_x.identifier, _x.action_type, _x.permission,) = _get_struct_3I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v55.name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v55.name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v55.application_data = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v55.application_data = str[start:end]
        _v57 = _v55.oneof_action_parameters
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v57.send_twist_command = []
        for i in range(0, length):
          val4 = kortex_driver.msg.TwistCommand()
          start = end
          end += 4
          (val4.reference_frame,) = _get_struct_I().unpack(str[start:end])
          _v58 = val4.twist
          _x = _v58
          start = end
          end += 24
          (_x.linear_x, _x.linear_y, _x.linear_z, _x.angular_x, _x.angular_y, _x.angular_z,) = _get_struct_6f().unpack(str[start:end])
          start = end
          end += 4
          (val4.duration,) = _get_struct_I().unpack(str[start:end])
          _v57.send_twist_command.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v57.send_wrench_command = []
        for i in range(0, length):
          val4 = kortex_driver.msg.WrenchCommand()
          _x = val4
          start = end
          end += 8
          (_x.reference_frame, _x.mode,) = _get_struct_2I().unpack(str[start:end])
          _v59 = val4.wrench
          _x = _v59
          start = end
          end += 24
          (_x.force_x, _x.force_y, _x.force_z, _x.torque_x, _x.torque_y, _x.torque_z,) = _get_struct_6f().unpack(str[start:end])
          start = end
          end += 4
          (val4.duration,) = _get_struct_I().unpack(str[start:end])
          _v57.send_wrench_command.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v57.send_joint_speeds = []
        for i in range(0, length):
          val4 = kortex_driver.msg.Base_JointSpeeds()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val4.joint_speeds = []
          for i in range(0, length):
            val5 = kortex_driver.msg.JointSpeed()
            _x = val5
            start = end
            end += 12
            (_x.joint_identifier, _x.value, _x.duration,) = _get_struct_IfI().unpack(str[start:end])
            val4.joint_speeds.append(val5)
          start = end
          end += 4
          (val4.duration,) = _get_struct_I().unpack(str[start:end])
          _v57.send_joint_speeds.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v57.reach_pose = []
        for i in range(0, length):
          val4 = kortex_driver.msg.ConstrainedPose()
          _v60 = val4.target_pose
          _x = _v60
          start = end
          end += 24
          (_x.x, _x.y, _x.z, _x.theta_x, _x.theta_y, _x.theta_z,) = _get_struct_6f().unpack(str[start:end])
          _v61 = val4.constraint
          _v62 = _v61.oneof_type
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v62.speed = []
          for i in range(0, length):
            val7 = kortex_driver.msg.CartesianSpeed()
            _x = val7
            start = end
            end += 8
            (_x.translation, _x.orientation,) = _get_struct_2f().unpack(str[start:end])
            _v62.speed.append(val7)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sI'%length
          start = end
          s = struct.Struct(pattern)
          end += s.size
          _v62.duration = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=length)
          _v57.reach_pose.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v57.reach_joint_angles = []
        for i in range(0, length):
          val4 = kortex_driver.msg.ConstrainedJointAngles()
          _v63 = val4.joint_angles
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v63.joint_angles = []
          for i in range(0, length):
            val6 = kortex_driver.msg.JointAngle()
            _x = val6
            start = end
            end += 8
            (_x.joint_identifier, _x.value,) = _get_struct_If().unpack(str[start:end])
            _v63.joint_angles.append(val6)
          _v64 = val4.constraint
          _x = _v64
          start = end
          end += 8
          (_x.type, _x.value,) = _get_struct_If().unpack(str[start:end])
          _v57.reach_joint_angles.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sI'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v57.toggle_admittance_mode = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v57.snapshot = []
        for i in range(0, length):
          val4 = kortex_driver.msg.Snapshot()
          start = end
          end += 4
          (val4.snapshot_type,) = _get_struct_I().unpack(str[start:end])
          _v57.snapshot.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v57.switch_control_mapping = []
        for i in range(0, length):
          val4 = kortex_driver.msg.SwitchControlMapping()
          start = end
          end += 4
          (val4.controller_identifier,) = _get_struct_I().unpack(str[start:end])
          _v65 = val4.map_group_handle
          _x = _v65
          start = end
          end += 8
          (_x.identifier, _x.permission,) = _get_struct_2I().unpack(str[start:end])
          _v66 = val4.map_handle
          _x = _v66
          start = end
          end += 8
          (_x.identifier, _x.permission,) = _get_struct_2I().unpack(str[start:end])
          _v57.switch_control_mapping.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sI'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v57.navigate_joints = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sI'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v57.navigate_mappings = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v57.change_twist = []
        for i in range(0, length):
          val4 = kortex_driver.msg.ChangeTwist()
          _x = val4
          start = end
          end += 8
          (_x.linear, _x.angular,) = _get_struct_2f().unpack(str[start:end])
          _v57.change_twist.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v57.change_joint_speeds = []
        for i in range(0, length):
          val4 = kortex_driver.msg.ChangeJointSpeeds()
          _v67 = val4.joint_speeds
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v67.joint_speeds = []
          for i in range(0, length):
            val6 = kortex_driver.msg.JointSpeed()
            _x = val6
            start = end
            end += 12
            (_x.joint_identifier, _x.value, _x.duration,) = _get_struct_IfI().unpack(str[start:end])
            _v67.joint_speeds.append(val6)
          start = end
          end += 4
          (_v67.duration,) = _get_struct_I().unpack(str[start:end])
          _v57.change_joint_speeds.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v57.change_wrench = []
        for i in range(0, length):
          val4 = kortex_driver.msg.ChangeWrench()
          _x = val4
          start = end
          end += 8
          (_x.force, _x.torque,) = _get_struct_2f().unpack(str[start:end])
          _v57.change_wrench.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v57.apply_emergency_stop = []
        for i in range(0, length):
          val4 = kortex_driver.msg.EmergencyStop()
          _v57.apply_emergency_stop.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v57.clear_faults = []
        for i in range(0, length):
          val4 = kortex_driver.msg.Faults()
          _v57.clear_faults.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v57.delay = []
        for i in range(0, length):
          val4 = kortex_driver.msg.Delay()
          start = end
          end += 4
          (val4.duration,) = _get_struct_I().unpack(str[start:end])
          _v57.delay.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v57.execute_action = []
        for i in range(0, length):
          val4 = kortex_driver.msg.ActionHandle()
          _x = val4
          start = end
          end += 12
          (_x.identifier, _x.action_type, _x.permission,) = _get_struct_3I().unpack(str[start:end])
          _v57.execute_action.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v57.send_gripper_command = []
        for i in range(0, length):
          val4 = kortex_driver.msg.GripperCommand()
          start = end
          end += 4
          (val4.mode,) = _get_struct_I().unpack(str[start:end])
          _v68 = val4.gripper
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          _v68.finger = []
          for i in range(0, length):
            val6 = kortex_driver.msg.Finger()
            _x = val6
            start = end
            end += 8
            (_x.finger_identifier, _x.value,) = _get_struct_If().unpack(str[start:end])
            _v68.finger.append(val6)
          start = end
          end += 4
          (val4.duration,) = _get_struct_I().unpack(str[start:end])
          _v57.send_gripper_command.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v57.stop_action = []
        for i in range(0, length):
          val4 = kortex_driver.msg.Base_Stop()
          _v57.stop_action.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v57.play_pre_computed_trajectory = []
        for i in range(0, length):
          val4 = kortex_driver.msg.PreComputedJointTrajectory()
          start = end
          end += 4
          (val4.mode,) = _get_struct_I().unpack(str[start:end])
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val4.trajectory_elements = []
          for i in range(0, length):
            val5 = kortex_driver.msg.PreComputedJointTrajectoryElement()
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            pattern = '<%sf'%length
            start = end
            s = struct.Struct(pattern)
            end += s.size
            val5.joint_angles = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            pattern = '<%sf'%length
            start = end
            s = struct.Struct(pattern)
            end += s.size
            val5.joint_speeds = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            pattern = '<%sf'%length
            start = end
            s = struct.Struct(pattern)
            end += s.size
            val5.joint_accelerations = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
            start = end
            end += 4
            (val5.time_from_start,) = _get_struct_f().unpack(str[start:end])
            val4.trajectory_elements.append(val5)
          _v57.play_pre_computed_trajectory.append(val4)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.name = str[start:end]
        self.input.elements.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2I = None
def _get_struct_2I():
    global _struct_2I
    if _struct_2I is None:
        _struct_2I = struct.Struct("<2I")
    return _struct_2I
_struct_2f = None
def _get_struct_2f():
    global _struct_2f
    if _struct_2f is None:
        _struct_2f = struct.Struct("<2f")
    return _struct_2f
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_6f = None
def _get_struct_6f():
    global _struct_6f
    if _struct_6f is None:
        _struct_6f = struct.Struct("<6f")
    return _struct_6f
_struct_If = None
def _get_struct_If():
    global _struct_If
    if _struct_If is None:
        _struct_If = struct.Struct("<If")
    return _struct_If
_struct_IfI = None
def _get_struct_IfI():
    global _struct_IfI
    if _struct_IfI is None:
        _struct_IfI = struct.Struct("<IfI")
    return _struct_IfI
_struct_f = None
def _get_struct_f():
    global _struct_f
    if _struct_f is None:
        _struct_f = struct.Struct("<f")
    return _struct_f
# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from kortex_driver/CreateMapResponse.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import kortex_driver.msg

class CreateMapResponse(genpy.Message):
  _md5sum = "335f209b31742c233f4d4fd3cb08b30f"
  _type = "kortex_driver/CreateMapResponse"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """MapHandle output

================================================================================
MSG: kortex_driver/MapHandle

uint32 identifier
uint32 permission"""
  __slots__ = ['output']
  _slot_types = ['kortex_driver/MapHandle']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       output

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(CreateMapResponse, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.output is None:
        self.output = kortex_driver.msg.MapHandle()
    else:
      self.output = kortex_driver.msg.MapHandle()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_2I().pack(_x.output.identifier, _x.output.permission))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.output is None:
        self.output = kortex_driver.msg.MapHandle()
      end = 0
      _x = self
      start = end
      end += 8
      (_x.output.identifier, _x.output.permission,) = _get_struct_2I().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_2I().pack(_x.output.identifier, _x.output.permission))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.output is None:
        self.output = kortex_driver.msg.MapHandle()
      end = 0
      _x = self
      start = end
      end += 8
      (_x.output.identifier, _x.output.permission,) = _get_struct_2I().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2I = None
def _get_struct_2I():
    global _struct_2I
    if _struct_2I is None:
        _struct_2I = struct.Struct("<2I")
    return _struct_2I
class CreateMap(object):
  _type          = 'kortex_driver/CreateMap'
  _md5sum = 'eba074d4d6ffdac1f0d6448381806633'
  _request_class  = CreateMapRequest
  _response_class = CreateMapResponse
